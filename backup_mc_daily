#!/bin/bash
# This script is intended to be run by cron for periodic backups of Minecraft data.
# The script scans the logs for player names, the number of times they've joined and the most recent date they've joined.
# The log search is used as criteria to determine if a backup is required. If a player with more than minimum_plays has 
#   joined since the last backup then a backup is required.
# Sample cron entry 0 10 * * * /home/mcserver/minecraft/mc_backup/backup_mc_daily runs the script at 10:00 AM every day.
# Edit the config.yml file to change constants and preferences according to your needs and data structure.
# James S. Lucas - 20230813

# Load the config.yml file
# Function code credit Stefan Farestam: https://stackoverflow.com/questions/5014632/how-can-i-parse-a-yaml-file-from-a-linux-shell-script/21189044#21189044
function parse_yaml {
   local prefix=$2
   local s='[[:space:]]*' w='[a-zA-Z0-9_]*' fs=$(echo @|tr @ '\034')
   sed -ne "s|^\($s\):|\1|" \
        -e 's|`||g;s|\$||g;' \
        -e "s|^\($s\)\($w\)$s:$s[\"']\(.*\)[\"']$s\$|\1$fs\2$fs\3|p" \
        -e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p"  $1 |
   awk -F$fs '{
      indent = length($1)/2;
      vname[indent] = $2;
      for (i in vname) {if (i > indent) {delete vname[i]}}
      if (length($3) > 0) {
         vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
         printf("%s%s%s=\"%s\"\n", "'$prefix'",vn, $2, $3);
      }
   }'
}

eval $(parse_yaml /home/mcserver/minecraft/mc_backup/config.yml)

script_start_time=$(date +"%Y-%m-%d %H:%M:%S")

force_backup="False"

while getopts ":f" opt; do
    case $opt in
        f)
            force_backup="True"
            ;;
        \?)
            echo "Invalid option: -$OPTARG" >&2
            ;;
    esac
done

# Change the directory to the log folder
cd "$CONSTANTS_LOG_PATH"

# Initialize variables to store the most recent file and date
most_recent_file=""
most_recent_date="0000-00-00"  # Initialize with a date in the past

# Function to get the modification date of a file in "YYYY-MM-DD" format
get_file_date() {
    local file="$1"
    # Get the date of the file and format it as "YYYY-MM-DD"
    date -r "$file" +"%Y-%m-%d"
}

find_world_paths() {
    WORLD_PATHS=()
    while IFS= read -r -d '' dir; do
        WORLD_PATHS+=("$dir")
    done < <(find "$CONSTANTS_MINECRAFT_PATH" -maxdepth 1 -type d -name "world*" -print0)
}

if [[ "$force_backup" == "False" ]]; then
    # Initialize an associative array to store player names and their occurrence count
    declare -A player_counts

    # Loop through each .gz file in the logs directory
    for file in *.gz; do
        # Use zgrep to search for player names and extract them
        names_found=$(zgrep -oE '[[:alnum:]_]+ joined the game' "$file" | awk '{print $1}')
        
        # Increment the occurrence count of each player name in the associative array
        for name in $names_found; do
            ((player_counts["$name"]++))
        done
    done

    # Initialize an empty array to store player names that meet the minimum play requirement
    search_strings=()

    # Loop through the associative array and filter player names based on the minimum_play count
    for name in "${!player_counts[@]}"; do
        count="${player_counts[$name]}"
        if ((count >= PREFS_MINIMUM_PLAYS)); then
            search_strings+=("$name")
        fi
    done

    # Search for each search string (player name) in the log files and determine the date of the most recent file containing a player name
    for search_string in "${search_strings[@]}"; do
        # Use find to search for .log files and .gz files containing the current search string
        # and compare their dates to find the most recent log file that includes one of the player names.
        while IFS= read -r file; do
            if [[ "$file" == *.gz ]]; then
                # For .gz files, use zgrep
                if zgrep -q "$search_string" "$file"; then
                    # Get the date of the file
                    file_date=$(get_file_date "$file")
                    # Compare the date of the current file with the most_recent_date
                    if [[ "$file_date" > "$most_recent_date" ]]; then
                        most_recent_file="$file"
                        most_recent_date="$file_date"
                    fi
                fi
            else
                # For uncompressed .log files, use grep
                if grep -q "$search_string" "$file"; then
                    # Get the date of the file
                    file_date=$(get_file_date "$file")
                    # Compare the date of the current file with the most_recent_date
                    if [[ "$file_date" > "$most_recent_date" ]]; then
                        most_recent_file="$file"
                        most_recent_date="$file_date"
                    fi
                fi
            fi
        done < <(find "$CONSTANTS_LOG_PATH" -type f \( -name "*.log" -o -name "*.gz" \))
    done

    # Check if the most recent backup is earlier or later than the most recent log file containing a player name
    if [[ "$most_recent_date" != "0000-00-00" ]]; then
        # Check if any files in the backup folder are newer than the most recent date
        if [[ $(find "$CONSTANTS_BACKUP_PATH" -type f -name "*.gz" -newermt "$most_recent_date" 2>/dev/null) ]]; then
            result="True: Some files in $CONSTANTS_BACKUP_PATH were created after $most_recent_date."
        else
            result="False: No files in $CONSTANTS_BACKUP_PATH were created after $most_recent_date."
        fi
    else
        result="None of the search strings found in any of the .log files."
    fi
fi


if [[ $result == *"False"* ] || [ $force_backup == "True"]]; then
    # Execute the backup.
    screen -R mc -xX stuff "say Server backup starting. World not saving until complete...$(printf '\r')"
    screen -R mc -xX stuff "save-off$(printf '\r')"
    screen -R mc -xX stuff "save-all$(printf '\r')"
    sleep 3

    # Move the existing backup files 0 -> 1, 1 -> 2, etc.
    for ((i=PREFS_NUM_DAYS-1; i>0; i--)); do
        current_day=$((i - 1))
        if [ -f "${CONSTANTS_BACKUP_PATH}/minecraft_day${current_day}.tar.gz" ]; then
            mv "${CONSTANTS_BACKUP_PATH}/minecraft_day${current_day}.tar.gz" "${CONSTANTS_BACKUP_PATH}/minecraft_day${i}.tar.gz"
        fi
    done

    # Create tha backup.
    find_world_paths
    tar -cpvzf "${CONSTANTS_BACKUP_PATH}/minecraft_day0.tar.gz" "${WORLD_PATHS[@]}"

    screen -R mc -xX stuff "save-on$(printf '\r')"
    screen -R mc -xX stuff "say Server backup complete. World now saving. $(printf '\r')"
    
    if [[ "$PREFS_USE_RCLONE" == "True" ]]; then
        # Move the existing rclone remote backup files 0 -> 1, 1 -> 2, etc.
        for ((i=PREFS_NUM_DAYS-1; i>0; i--)); do
            current_day=$((i - 1))
            rclone moveto "${CONSTANTS_RCLONE_REMOTE}:minecraft_day${current_day}.tar.gz" "${CONSTANTS_RCLONE_REMOTE}:minecraft_day${i}.tar.gz"
        done
        # Copy the new backup to the rclone remote
        rclone copy "${CONSTANTS_BACKUP_PATH}/minecraft_day0.tar.gz" "${CONSTANTS_RCLONE_REMOTE}:"
    fi
    echo "backup run from $script_start_time to $(date +"%Y-%m-%d %H:%M:%S %Z")" >> "${CONSTANTS_BACKUP_PATH}/backup_log.txt"
    rclone copy "${CONSTANTS_BACKUP_PATH}/backup_log.txt" "${CONSTANTS_RCLONE_REMOTE}:"
else
    echo "World not modified since most recent backup, no backup required. $(printf '\r')"
fi